<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Get Next Line - Visualizer Interactif</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #d1d5db; /* text-gray-300 */
        }
        .fira-code {
            font-family: 'Fira Code', monospace;
        }
        .card {
            background-color: #1f2937; /* bg-gray-800 */
            border: 1px solid #374151; /* border-gray-700 */
            border-radius: 0.75rem; /* rounded-xl */
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .textarea-custom {
            background-color: #374151; /* bg-gray-700 */
            border: 1px solid #4b5563; /* border-gray-600 */
            color: #e5e7eb; /* text-gray-200 */
        }
        .highlight-read {
            background-color: rgba(59, 130, 246, 0.3); /* bg-blue-500/30 */
            color: #eff6ff; /* text-blue-50 */
        }
        .highlight-line {
            background-color: rgba(34, 197, 94, 0.3); /* bg-green-500/30 */
            color: #f0fdf4; /* text-green-50 */
        }
        .highlight-buffer {
             background-color: rgba(234, 179, 8, 0.2); /* bg-yellow-500/20 */
             border: 1px dashed rgba(234, 179, 8, 0.6);
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto">

        <!-- Header -->
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold text-white mb-2">
                Get Next Line <span class="text-blue-400">Visualizer</span>
            </h1>
            <p class="text-lg text-gray-400">Un outil pour décortiquer et maîtriser le comportement de GNL.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">

            <!-- Colonne de Contrôle et Simulation -->
            <div class="card p-6 flex flex-col space-y-6">
                <h2 class="text-2xl font-bold text-white border-b border-gray-700 pb-3">1. Simulation</h2>
                
                <!-- Scénarios de test -->
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Charger un scénario de test :</label>
                    <select id="test-case-selector" class="w-full p-2.5 textarea-custom rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="custom">Personnalisé</option>
                        <option value="simple">Simple</option>
                        <option value="no_newline">Pas de retour à la ligne</option>
                        <option value="empty_lines">Lignes vides</option>
                        <option value="ends_with_newline">Finit par un newline</option>
                        <option value="big_line">Ligne très longue</option>
                         <option value="multiple_fd">Lectures multiples (simulé)</option>
                    </select>
                </div>

                <!-- Contenu du Fichier -->
                <div>
                    <label for="file-content" class="block text-sm font-medium text-gray-300 mb-2">Contenu du "fichier" :</label>
                    <textarea id="file-content" rows="8" class="w-full p-3 fira-code text-sm textarea-custom rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="Entrez le contenu de votre fichier ici. Utilisez \n pour les sauts de ligne."></textarea>
                </div>

                <!-- BUFFER_SIZE -->
                <div>
                    <label for="buffer-size" class="block text-sm font-medium text-gray-300 mb-2">BUFFER_SIZE :</label>
                    <input type="number" id="buffer-size" value="32" min="1" class="w-full p-2.5 textarea-custom rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </div>

                <!-- Boutons de Contrôle -->
                <div class="flex flex-col sm:flex-row gap-4 pt-4 border-t border-gray-700">
                    <button id="next-line-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg btn">
                        Appeler get_next_line()
                    </button>
                    <button id="reset-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg btn">
                        Réinitialiser
                    </button>
                </div>
            </div>

            <!-- Colonne de Visualisation -->
            <div class="card p-6 flex flex-col space-y-6">
                <h2 class="text-2xl font-bold text-white border-b border-gray-700 pb-3">2. Visualisation</h2>
                
                <!-- Ligne Retournée -->
                <div>
                    <h3 class="text-lg font-semibold text-white mb-2">Ligne retournée par GNL :</h3>
                    <div id="returned-line" class="p-4 textarea-custom rounded-lg min-h-[50px] fira-code text-sm whitespace-pre-wrap break-words">
                        <span class="text-gray-500">En attente du premier appel...</span>
                    </div>
                     <div id="return-value-info" class="text-right text-xs text-gray-400 mt-1"></div>
                </div>

                <!-- État de la variable statique -->
                <div>
                    <h3 class="text-lg font-semibold text-white mb-2">Contenu de la variable statique (buffer interne) :</h3>
                    <div id="static-var" class="p-4 textarea-custom rounded-lg min-h-[80px] fira-code text-sm whitespace-pre-wrap break-words">
                         <span class="text-gray-500">Vide.</span>
                    </div>
                </div>

                <!-- Visualisation du fichier -->
                <div>
                    <h3 class="text-lg font-semibold text-white mb-2">Visualisation de la lecture :</h3>
                    <div id="file-visualization" class="p-4 textarea-custom rounded-lg min-h-[120px] fira-code text-sm whitespace-pre-wrap break-words">
                        <span class="text-gray-500">Le contenu du fichier apparaîtra ici.</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Section Explications -->
        <div class="card p-6 mt-8">
             <h2 class="text-2xl font-bold text-white border-b border-gray-700 pb-3 mb-4">3. Logique de Get Next Line</h2>
             <div class="space-y-4 text-gray-300">
                <p>
                    Le but de <strong>get_next_line</strong> est de lire un fichier ligne par ligne. La difficulté vient du fait qu'on ne peut lire le fichier que par "morceaux" de taille <code>BUFFER_SIZE</code>.
                </p>
                <ol class="list-decimal list-inside space-y-3 pl-4">
                    <li>
                        <strong>La variable statique est la clé :</strong> Elle conserve ce qui a été lu mais pas encore retourné. C'est la mémoire de votre fonction entre deux appels. Si vous lisez <code>"abc\ndef"</code> avec un <code>BUFFER_SIZE</code> de 5, votre buffer interne contiendra <code>"abc\n"</code>. Au premier appel, vous retournez <code>"abc\n"</code> et votre statique gardera <code>"def"</code> pour le prochain appel.
                    </li>
                    <li>
                        <strong>Boucle de lecture :</strong> Vous devez lire le fichier (avec la fonction <code>read</code>) et ajouter le contenu lu à votre variable statique, jusqu'à ce que celle-ci contienne un retour à la ligne (<code>\n</code>) ou que la lecture soit terminée.
                    </li>
                    <li>
                        <strong>Extraction de la ligne :</strong> Une fois qu'un <code>\n</code> est trouvé dans la statique, vous devez "extraire" tout ce qui se trouve avant (et y compris) ce <code>\n</code>. C'est la ligne que votre fonction doit retourner.
                    </li>
                    <li>
                        <strong>Nettoyage de la statique :</strong> Après avoir extrait la ligne, le reste doit être conservé dans la variable statique pour les appels futurs. Si votre statique contenait <code>"ligne1\nligne2"</code>, vous retournez <code>"ligne1\n"</code> et votre statique doit maintenant contenir <code>"ligne2"</code>.
                    </li>
                     <li>
                        <strong>Fin du fichier (EOF) :</strong> Si <code>read</code> retourne 0, cela signifie que vous avez atteint la fin du fichier. S'il reste quelque chose dans votre variable statique, il faut le retourner (c'est la dernière ligne, qui peut ne pas avoir de <code>\n</code>). Sinon, vous retournez <code>NULL</code> pour signaler la fin. Si <code>read</code> retourne -1, c'est une erreur.
                    </li>
                </ol>
             </div>
        </div>

    </div>

    <script>
        // --- Éléments du DOM ---
        const fileContentEl = document.getElementById('file-content');
        const bufferSizeEl = document.getElementById('buffer-size');
        const nextLineBtn = document.getElementById('next-line-btn');
        const resetBtn = document.getElementById('reset-btn');
        const returnedLineEl = document.getElementById('returned-line');
        const staticVarEl = document.getElementById('static-var');
        const fileVizEl = document.getElementById('file-visualization');
        const testCaseSelector = document.getElementById('test-case-selector');
        const returnValueInfoEl = document.getElementById('return-value-info');

        // --- État de la simulation ---
        // On utilise un objet pour simuler les variables statiques pour plusieurs 'fd'
        let staticStorage = {}; 
        let currentFd = 0; // descripteur de fichier par défaut
        let readPosition = 0;
        let fileText = '';

        // --- Scénarios de test ---
        const testCases = {
            custom: ``,
            simple: `Première ligne.\nDeuxième ligne.\nTroisième ligne.`,
            no_newline: `Une seule longue ligne sans retour.`,
            empty_lines: `Ligne 1\n\nLigne 3\n\n`,
            ends_with_newline: `Ligne A\nLigne B\n`,
            big_line: `Voici une ligne qui est volontairement beaucoup plus longue que la plupart des buffer sizes pour tester la boucle de lecture. C'est un bon test.`,
            multiple_fd: `Fichier 1, Ligne 1\nFichier 1, Ligne 2\nFichier 1, Ligne 3`
        };
        
        // --- Fonctions de l'interface ---

        function setup() {
            fileText = fileContentEl.value.replace(/\\n/g, '\n');
            readPosition = 0;
            staticStorage = { 0: '' }; // Reset pour le fd 0
            
            // Pour le cas multi-fd, on prépare un second "fichier"
            if (testCaseSelector.value === 'multiple_fd') {
                staticStorage[1] = '';
                // On pourrait avoir un autre textarea pour le 2e fichier, mais pour la simplicité on simule
            }

            updateFileVisualization();
            updateStaticVarVisualization();
            returnedLineEl.innerHTML = '<span class="text-gray-500">Prêt à appeler GNL.</span>';
            returnValueInfoEl.textContent = '';
            nextLineBtn.disabled = false;
        }
        
        function resetSimulation() {
            loadTestCase();
        }
        
        function loadTestCase() {
            const selectedCase = testCaseSelector.value;
            if (selectedCase === 'multiple_fd') {
                fileContentEl.value = testCases[selectedCase];
                alert("Mode Multi-FD Simulé :\nL'outil va maintenant alterner les appels entre fd=0 et fd=1.\nRegardez comment la variable statique change pour chaque 'fichier'.");
            } else {
                fileContentEl.value = testCases[selectedCase].replace(/\n/g, '\\n');
            }
            setup();
        }

        function updateFileVisualization() {
            if (!fileText) {
                fileVizEl.innerHTML = '<span class="text-gray-500">Le contenu du fichier apparaîtra ici.</span>';
                return;
            }
            const beforeRead = fileText.substring(0, readPosition);
            const lastRead = fileText.substring(readPosition, readPosition + (lastBytesRead > 0 ? lastBytesRead : 0) );
            const afterRead = fileText.substring(readPosition + (lastBytesRead > 0 ? lastBytesRead : 0));
            
            fileVizEl.innerHTML = '';
            fileVizEl.appendChild(document.createTextNode(beforeRead));
            
            const spanRead = document.createElement('span');
            spanRead.className = 'highlight-read';
            spanRead.textContent = lastRead;
            fileVizEl.appendChild(spanRead);
            
            fileVizEl.appendChild(document.createTextNode(afterRead));
        }

        function updateStaticVarVisualization(lineExtracted = '') {
            const staticContent = staticStorage[currentFd] || '';
            if (!staticContent && !lineExtracted) {
                staticVarEl.innerHTML = '<span class="text-gray-500">Vide.</span>';
                return;
            }
            
            staticVarEl.innerHTML = '';

            if(lineExtracted) {
                const spanLine = document.createElement('span');
                spanLine.className = 'highlight-line';
                spanLine.textContent = lineExtracted.replace(/\n/g, '↵\n');
                staticVarEl.appendChild(spanLine);
            }
            
            const spanBuffer = document.createElement('span');
            spanBuffer.className = 'highlight-buffer';
            spanBuffer.textContent = staticContent.replace(/\n/g, '↵\n');
            staticVarEl.appendChild(spanBuffer);
        }

        function displayReturnedLine(line) {
            if (line === null) {
                returnedLineEl.innerHTML = '<span class="text-yellow-400 font-bold">NULL</span>';
                returnValueInfoEl.textContent = 'Fin de la lecture.';
                nextLineBtn.disabled = true;
            } else if (line === 'ERROR') {
                 returnedLineEl.innerHTML = '<span class="text-red-500 font-bold">ERROR</span>';
                 returnValueInfoEl.textContent = 'Une erreur de lecture est survenue.';
                 nextLineBtn.disabled = true;
            } else {
                returnedLineEl.textContent = line.replace(/\n/g, '↵\n');
                returnValueInfoEl.textContent = `Retourne une chaîne de ${line.length} char.`;
            }
        }


        // --- Logique de simulation de GNL ---
        let lastBytesRead = 0;

        function mock_read(bufferSize) {
            if (readPosition >= fileText.length) {
                return ''; // EOF
            }
            const chunk = fileText.substring(readPosition, readPosition + bufferSize);
            readPosition += chunk.length;
            lastBytesRead = chunk.length;
            return chunk;
        }

        function getNextLineSimulator() {
            lastBytesRead = 0;
            let staticBuffer = staticStorage[currentFd] || '';
            const bufferSize = parseInt(bufferSizeEl.value, 10);
            
            if (isNaN(bufferSize) || bufferSize <= 0) {
                 alert("BUFFER_SIZE doit être un nombre positif.");
                 return 'ERROR';
            }

            // Boucle de lecture jusqu'à trouver un \n ou la fin du fichier
            while (!staticBuffer.includes('\n')) {
                const chunk = mock_read(bufferSize);
                if (chunk === '') { // EOF
                    break;
                }
                staticBuffer += chunk;
            }
            
            staticStorage[currentFd] = staticBuffer;
            updateFileVisualization();

            // Si pas de buffer et lecture finie, on a tout lu.
            if (staticBuffer === '') {
                updateStaticVarVisualization();
                return null;
            }

            // Extraction de la ligne
            const newlineIndex = staticBuffer.indexOf('\n');
            let lineToReturn;
            let remainingBuffer;

            if (newlineIndex !== -1) {
                lineToReturn = staticBuffer.substring(0, newlineIndex + 1);
                remainingBuffer = staticBuffer.substring(newlineIndex + 1);
            } else {
                // Pas de \n, mais il reste du texte (dernière ligne)
                lineToReturn = staticBuffer;
                remainingBuffer = '';
            }

            updateStaticVarVisualization(lineToReturn);
            staticStorage[currentFd] = remainingBuffer;
            
            return lineToReturn;
        }
        
        let fd_turn = 0;
        function handleNextLineClick() {
            if (testCaseSelector.value === 'multiple_fd') {
                currentFd = fd_turn;
                alert(`Appel de GNL pour le fd = ${currentFd}`);
                fd_turn = (fd_turn + 1) % 2; // Alterne entre 0 et 1
                // Pour la simplicité, on lit toujours du même fichier source
                // mais on utilise des buffers statiques différents.
                // Dans un vrai scénario, chaque fd aurait sa propre position de lecture.
                // Ici, on réinitialise la position pour simuler une lecture indépendante.
                if(currentFd === 1) {
                    // On simule un second fichier identique pour la démo
                    fileText = "Fichier 2, Ligne A\nFichier 2, Ligne B";
                    readPosition = 0;
                } else {
                    fileText = testCases.multiple_fd;
                    readPosition = 0;
                }
            } else {
                 currentFd = 0;
            }

            const line = getNextLineSimulator();
            displayReturnedLine(line);
            
            // On met à jour la visualisation de la statique une dernière fois
            // pour montrer ce qu'il reste APRES le retour.
            setTimeout(() => {
                 updateStaticVarVisualization();
            }, 100);
        }

        // --- Écouteurs d'événements ---
        nextLineBtn.addEventListener('click', handleNextLineClick);
        resetBtn.addEventListener('click', resetSimulation);
        testCaseSelector.addEventListener('change', loadTestCase);
        
        // Initialisation
        window.addEventListener('load', () => {
            loadTestCase();
        });

    </script>
</body>
</html>
